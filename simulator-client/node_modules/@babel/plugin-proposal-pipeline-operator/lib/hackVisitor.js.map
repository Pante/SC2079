{"version":3,"names":["_core","require","topicReferenceVisitor","exit","path","state","isTopicReference","topicReferences","push","length","sideEffectsBeforeFirstTopicReference","isPure","ClassBody|Function","_","visitor","BinaryExpression","scope","node","operator","pipeBodyPath","get","type","replaceWith","left","visitorState","isFunction","traverse","right","topicVariable","generateUidIdentifierBasedOnNode","id","forEach","t","cloneNode","sequenceExpression","assignmentExpression","_default","exports","default"],"sources":["../src/hackVisitor.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\nimport type { PluginPass } from \"@babel/core\";\n\ntype State = {\n  topicReferences: NodePath<t.TopicReference>[];\n  sideEffectsBeforeFirstTopicReference: boolean;\n};\n\nconst topicReferenceVisitor: Visitor<State> = {\n  exit(path, state) {\n    if (path.isTopicReference()) {\n      state.topicReferences.push(path);\n    } else {\n      if (\n        state.topicReferences.length === 0 &&\n        !state.sideEffectsBeforeFirstTopicReference &&\n        !path.isPure()\n      ) {\n        state.sideEffectsBeforeFirstTopicReference = true;\n      }\n    }\n  },\n  \"ClassBody|Function\"(_, state) {\n    if (state.topicReferences.length === 0) {\n      state.sideEffectsBeforeFirstTopicReference = true;\n    }\n  },\n};\n\n// This visitor traverses `BinaryExpression`\n// and replaces any that use `|>`\n// with sequence expressions containing assignment expressions\n// with automatically generated variables,\n// from inside to outside, from left to right.\nconst visitor: Visitor<PluginPass> = {\n  BinaryExpression: {\n    exit(path) {\n      const { scope, node } = path;\n\n      if (node.operator !== \"|>\") {\n        // The path node is a binary expression,\n        // but it is not a pipe expression.\n        return;\n      }\n\n      const pipeBodyPath = path.get(\"right\");\n      if (pipeBodyPath.node.type === \"TopicReference\") {\n        // If the pipe body is itself a lone topic reference,\n        // then replace the whole expression with its left operand.\n        path.replaceWith(node.left);\n        return;\n      }\n\n      const visitorState: State = {\n        topicReferences: [],\n        // pipeBodyPath might be a function, and it won't be visited by\n        // topicReferenceVisitor because traverse() skips the top-level\n        // node. We must handle that case here manually.\n        sideEffectsBeforeFirstTopicReference: pipeBodyPath.isFunction(),\n      };\n      pipeBodyPath.traverse(topicReferenceVisitor, visitorState);\n\n      if (\n        visitorState.topicReferences.length === 1 &&\n        (!visitorState.sideEffectsBeforeFirstTopicReference ||\n          path.scope.isPure(node.left, true))\n      ) {\n        visitorState.topicReferences[0].replaceWith(node.left);\n        path.replaceWith(node.right);\n        return;\n      }\n\n      const topicVariable = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: topicVariable });\n\n      // Replace topic references with the topic variable.\n      visitorState.topicReferences.forEach(path =>\n        path.replaceWith(t.cloneNode(topicVariable)),\n      );\n\n      // Replace the pipe expression itself with an assignment expression.\n      path.replaceWith(\n        t.sequenceExpression([\n          t.assignmentExpression(\n            \"=\",\n            t.cloneNode(topicVariable),\n            // @ts-expect-error node.left must not be a PrivateName when operator is |>\n            node.left,\n          ),\n          node.right,\n        ]),\n      );\n    },\n  },\n};\n\nexport default visitor;\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AASA,MAAMC,qBAAqC,GAAG;EAC5CC,IAAIA,CAACC,IAAI,EAAEC,KAAK,EAAE;IAChB,IAAID,IAAI,CAACE,gBAAgB,CAAC,CAAC,EAAE;MAC3BD,KAAK,CAACE,eAAe,CAACC,IAAI,CAACJ,IAAI,CAAC;IAClC,CAAC,MAAM;MACL,IACEC,KAAK,CAACE,eAAe,CAACE,MAAM,KAAK,CAAC,IAClC,CAACJ,KAAK,CAACK,oCAAoC,IAC3C,CAACN,IAAI,CAACO,MAAM,CAAC,CAAC,EACd;QACAN,KAAK,CAACK,oCAAoC,GAAG,IAAI;MACnD;IACF;EACF,CAAC;EACD,oBAAoBE,CAACC,CAAC,EAAER,KAAK,EAAE;IAC7B,IAAIA,KAAK,CAACE,eAAe,CAACE,MAAM,KAAK,CAAC,EAAE;MACtCJ,KAAK,CAACK,oCAAoC,GAAG,IAAI;IACnD;EACF;AACF,CAAC;AAOD,MAAMI,OAA4B,GAAG;EACnCC,gBAAgB,EAAE;IAChBZ,IAAIA,CAACC,IAAI,EAAE;MACT,MAAM;QAAEY,KAAK;QAAEC;MAAK,CAAC,GAAGb,IAAI;MAE5B,IAAIa,IAAI,CAACC,QAAQ,KAAK,IAAI,EAAE;QAG1B;MACF;MAEA,MAAMC,YAAY,GAAGf,IAAI,CAACgB,GAAG,CAAC,OAAO,CAAC;MACtC,IAAID,YAAY,CAACF,IAAI,CAACI,IAAI,KAAK,gBAAgB,EAAE;QAG/CjB,IAAI,CAACkB,WAAW,CAACL,IAAI,CAACM,IAAI,CAAC;QAC3B;MACF;MAEA,MAAMC,YAAmB,GAAG;QAC1BjB,eAAe,EAAE,EAAE;QAInBG,oCAAoC,EAAES,YAAY,CAACM,UAAU,CAAC;MAChE,CAAC;MACDN,YAAY,CAACO,QAAQ,CAACxB,qBAAqB,EAAEsB,YAAY,CAAC;MAE1D,IACEA,YAAY,CAACjB,eAAe,CAACE,MAAM,KAAK,CAAC,KACxC,CAACe,YAAY,CAACd,oCAAoC,IACjDN,IAAI,CAACY,KAAK,CAACL,MAAM,CAACM,IAAI,CAACM,IAAI,EAAE,IAAI,CAAC,CAAC,EACrC;QACAC,YAAY,CAACjB,eAAe,CAAC,CAAC,CAAC,CAACe,WAAW,CAACL,IAAI,CAACM,IAAI,CAAC;QACtDnB,IAAI,CAACkB,WAAW,CAACL,IAAI,CAACU,KAAK,CAAC;QAC5B;MACF;MAEA,MAAMC,aAAa,GAAGZ,KAAK,CAACa,gCAAgC,CAACZ,IAAI,CAAC;MAClED,KAAK,CAACR,IAAI,CAAC;QAAEsB,EAAE,EAAEF;MAAc,CAAC,CAAC;MAGjCJ,YAAY,CAACjB,eAAe,CAACwB,OAAO,CAAC3B,IAAI,IACvCA,IAAI,CAACkB,WAAW,CAACU,WAAC,CAACC,SAAS,CAACL,aAAa,CAAC,CAC7C,CAAC;MAGDxB,IAAI,CAACkB,WAAW,CACdU,WAAC,CAACE,kBAAkB,CAAC,CACnBF,WAAC,CAACG,oBAAoB,CACpB,GAAG,EACHH,WAAC,CAACC,SAAS,CAACL,aAAa,CAAC,EAE1BX,IAAI,CAACM,IACP,CAAC,EACDN,IAAI,CAACU,KAAK,CACX,CACH,CAAC;IACH;EACF;AACF,CAAC;AAAC,IAAAS,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEaxB,OAAO"}